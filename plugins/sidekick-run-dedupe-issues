#!/bin/bash

# GitHub Issue Deduplicator Plugin
# Identifies and removes duplicate GitHub issues, keeping only the newest

set -e

# Source shared libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
source "$SCRIPT_DIR/lib/config.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/output_helpers.sh" 2>/dev/null || true
source "$SCRIPT_DIR/plugins/lib/sidekick-run-dedupe-issues/issue_deduplicator.sh" 2>/dev/null || true

# Default values
THRESHOLD=85
DRY_RUN=true
CONFIRM=false
LIMIT=1000
VERBOSE=false
ORG=""
REPO=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Usage function
usage() {
    cat << EOF
Usage: sidekick run dedupe-issues [OPTIONS] [org] [repo]

Identify and remove duplicate GitHub issues, keeping only the newest.

OPTIONS:
    -t, --threshold NUM    Similarity threshold (0-100, default: 85)
    -n, --dry-run         Preview without making changes (default)
    -c, --confirm         Execute the deduplication (removes dry-run)
    -l, --limit NUM       Maximum issues to process (default: 1000)
    -v, --verbose         Show detailed processing information
    -h, --help           Show this help message

ARGUMENTS:
    org     GitHub organization (uses SIDEKICK_GITHUB_ORG if not provided)
    repo    GitHub repository (uses SIDEKICK_GITHUB_REPO if not provided)

EXAMPLES:
    # Preview duplicates (dry-run mode)
    sidekick run dedupe-issues myorg myrepo
    
    # Actually close duplicate issues
    sidekick run dedupe-issues --confirm myorg myrepo
    
    # Use stricter similarity threshold
    sidekick run dedupe-issues --threshold 90 myorg myrepo
    
    # Process limited number of issues
    sidekick run dedupe-issues --limit 100 myorg myrepo

ENVIRONMENT:
    SIDEKICK_GITHUB_ORG     Default GitHub organization
    SIDEKICK_GITHUB_REPO    Default GitHub repository

SAFETY:
    This plugin runs in dry-run mode by default to prevent accidental
    issue closure. Use --confirm to actually close duplicate issues.
    
    Duplicates are determined by title similarity. The newest issue
    in each duplicate group is kept, older ones are closed with a
    reference comment.

EOF
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--threshold)
                THRESHOLD="$2"
                # Validate threshold
                if [[ ! "$THRESHOLD" =~ ^[0-9]+$ ]] || [[ "$THRESHOLD" -lt 0 ]] || [[ "$THRESHOLD" -gt 100 ]]; then
                    echo "Error: Invalid threshold. Must be between 0 and 100." >&2
                    exit 1
                fi
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                CONFIRM=false
                shift
                ;;
            -c|--confirm)
                CONFIRM=true
                DRY_RUN=false
                shift
                ;;
            -l|--limit)
                LIMIT="$2"
                if [[ ! "$LIMIT" =~ ^[0-9]+$ ]] || [[ "$LIMIT" -lt 1 ]]; then
                    echo "Error: Invalid limit. Must be a positive number." >&2
                    exit 1
                fi
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                echo "Error: Unknown option: $1" >&2
                usage
                exit 1
                ;;
            *)
                # Positional arguments
                if [[ -z "$ORG" ]]; then
                    ORG="$1"
                elif [[ -z "$REPO" ]]; then
                    REPO="$1"
                else
                    echo "Error: Too many arguments" >&2
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# Main function
main() {
    # Parse arguments
    parse_arguments "$@"
    
    # Load environment defaults if available
    load_sidekick_config silent 2>/dev/null || true
    
    # Use environment defaults if not provided
    ORG="${ORG:-$(get_github_org_or_user 2>/dev/null || echo '')}"
    REPO="${REPO:-$DEFAULT_GITHUB_REPO}"
    
    # Validate required arguments
    if [[ -z "$ORG" ]] || [[ -z "$REPO" ]]; then
        echo "Error: Missing required arguments: organization and repository" >&2
        echo "Provide them as arguments or set SIDEKICK_GITHUB_ORG and SIDEKICK_GITHUB_REPO" >&2
        exit 1
    fi
    
    # Show configuration
    if [[ "$VERBOSE" == "true" ]]; then
        echo "Verbose mode enabled" >&2
        echo "Configuration:" >&2
        echo "  Organization: $ORG" >&2
        echo "  Repository: $REPO" >&2
        echo "  Threshold: $THRESHOLD%" >&2
        echo "  Limit: $LIMIT issues" >&2
        echo "  Mode: $(if [[ "$DRY_RUN" == "true" ]]; then echo "DRY RUN"; else echo "CONFIRM"; fi)" >&2
        echo "" >&2
    fi
    
    # Display mode banner
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${BOLD}${YELLOW}=== DRY RUN MODE ===${NC}"
        echo "No issues will be closed. Use --confirm to execute changes."
        echo ""
    else
        echo -e "${BOLD}${RED}=== CONFIRM MODE ===${NC}"
        echo "Issues WILL be closed. Press Ctrl+C to cancel."
        echo ""
        sleep 3
    fi
    
    # Show limit in output
    echo "Processing up to limit: $LIMIT issues from $ORG/$REPO"
    echo "Using similarity threshold: $THRESHOLD%"
    echo "Mode: $(if [[ "$DRY_RUN" == "true" ]]; then echo "DRY RUN"; else echo "CONFIRM"; fi)"
    echo ""
    
    # Fetch all open issues
    echo -e "${BOLD}${BLUE}Fetching issues...${NC}"
    local issues_json=$(fetch_all_issues "$ORG" "$REPO" "$LIMIT")
    local issue_count=$(echo "$issues_json" | jq 'length')
    
    if [[ $issue_count -eq 0 ]]; then
        echo -e "${YELLOW}No open issues found in $ORG/$REPO${NC}"
        exit 0
    fi
    
    echo -e "${GREEN}✓${NC} Found $issue_count open issues"
    echo ""
    
    # Find duplicate groups
    echo -e "${BOLD}${BLUE}Analyzing for duplicates...${NC}"
    local duplicate_groups=$(find_duplicate_groups "$issues_json" "$THRESHOLD")
    local group_count=$(echo "$duplicate_groups" | jq 'length')
    
    if [[ $group_count -eq 0 ]]; then
        echo -e "${GREEN}✓${NC} No duplicate issues found with threshold $THRESHOLD%"
        exit 0
    fi
    
    echo -e "${YELLOW}⚠${NC} Found $group_count groups of duplicate issues"
    echo ""
    
    # Process each duplicate group
    echo -e "${BOLD}${BLUE}Duplicate Groups:${NC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    local total_duplicates=0
    
    for ((g=0; g<$group_count; g++)); do
        local group=$(echo "$duplicate_groups" | jq ".[$g]")
        local processed=$(process_duplicate_group "$issues_json" "$group")
        
        local keeper=$(echo "$processed" | jq -r '.keeper')
        local duplicates=$(echo "$processed" | jq -r '.duplicates | @csv' | tr ',' ' ')
        local dup_count=$(echo "$processed" | jq '.duplicates | length')
        
        # Get keeper issue details
        local keeper_issue=$(echo "$issues_json" | jq ".[] | select(.number == $keeper)")
        local keeper_title=$(echo "$keeper_issue" | jq -r '.title')
        local keeper_url=$(echo "$keeper_issue" | jq -r '.url')
        
        echo -e "${BOLD}Group $((g+1)):${NC}"
        echo -e "  ${GREEN}✓ KEEP #$keeper:${NC} $keeper_title"
        echo -e "    URL: $keeper_url"
        
        # Show duplicates
        for dup_num in $duplicates; do
            local dup_issue=$(echo "$issues_json" | jq ".[] | select(.number == $dup_num)")
            local dup_title=$(echo "$dup_issue" | jq -r '.title')
            local dup_url=$(echo "$dup_issue" | jq -r '.url')
            
            echo -e "  ${RED}✗ CLOSE #$dup_num:${NC} $dup_title"
            echo -e "    URL: $dup_url"
            
            ((total_duplicates++))
        done
        echo ""
    done
    
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo ""
    
    # Summary
    echo -e "${BOLD}${CYAN}Summary:${NC}"
    echo "  Total issues: $issue_count"
    echo "  Duplicate groups: $group_count"
    echo "  Issues to close: $total_duplicates"
    echo ""
    
    # Execute or show what would be done
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}This was a dry run. No issues were closed.${NC}"
        echo "To actually close these issues, run with --confirm"
    else
        echo -e "${BOLD}${RED}Closing duplicate issues...${NC}"
        
        # Process each group again for actual closure
        for ((g=0; g<$group_count; g++)); do
            local group=$(echo "$duplicate_groups" | jq ".[$g]")
            local processed=$(process_duplicate_group "$issues_json" "$group")
            
            local keeper=$(echo "$processed" | jq -r '.keeper')
            local duplicates=$(echo "$processed" | jq -r '.duplicates[]')
            
            for dup_num in $duplicates; do
                echo -e "Closing issue #$dup_num as duplicate of #$keeper..."
                
                # Track success
                local close_success=true
                
                # Add comment with error handling
                local comment="Closing as duplicate of #$keeper\n\nThis issue appears to be a duplicate based on title similarity. Please continue the discussion in #$keeper."
                if ! gh issue comment "$dup_num" --repo "$ORG/$REPO" --body "$comment" 2>/dev/null; then
                    echo -e "  ${YELLOW}⚠${NC} Failed to add comment to #$dup_num"
                    close_success=false
                fi
                
                # Add label if it exists (non-critical, so continue on failure)
                gh issue edit "$dup_num" --repo "$ORG/$REPO" --add-label "duplicate" 2>/dev/null || true
                
                # Close the issue with retry
                local close_attempts=0
                local close_max_attempts=3
                local closed=false
                
                while [[ $close_attempts -lt $close_max_attempts ]] && [[ "$closed" == "false" ]]; do
                    if gh issue close "$dup_num" --repo "$ORG/$REPO" 2>/dev/null; then
                        closed=true
                    else
                        ((close_attempts++))
                        if [[ $close_attempts -lt $close_max_attempts ]]; then
                            sleep 1
                        fi
                    fi
                done
                
                if [[ "$closed" == "true" ]]; then
                    echo -e "  ${GREEN}✓${NC} Closed #$dup_num"
                else
                    echo -e "  ${RED}✗${NC} Failed to close #$dup_num after $close_max_attempts attempts"
                    close_success=false
                fi
                
                # Check for rate limiting
                if ! gh api rate_limit --jq '.rate.remaining' &>/dev/null; then
                    local remaining=$(gh api rate_limit --jq '.rate.remaining' 2>/dev/null || echo "0")
                    if [[ "$remaining" -lt 10 ]]; then
                        echo -e "${YELLOW}⚠ Warning: GitHub API rate limit is low ($remaining requests remaining)${NC}"
                        echo "Pausing for 30 seconds to avoid rate limiting..."
                        sleep 30
                    fi
                fi
            done
        done
        
        echo ""
        echo -e "${GREEN}✓${NC} Successfully closed $total_duplicates duplicate issues"
    fi
}

# Run main function
main "$@"