#!/bin/bash

# Sidekick Update Plugin
# Self-update functionality for sidekick

set -e

# Get the script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Source shared libraries
source "$SCRIPT_DIR/lib/config.sh" 2>/dev/null || true

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_info() {
    echo -e "${BLUE}→ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Show help
show_help() {
    cat << EOF
Sidekick Update - Self-update tool for sidekick

Usage:
  sidekick update [OPTIONS]
  sidekick update [VERSION]

Description:
  Updates sidekick to the latest version or a specific version.
  
Options:
  -c, --check       Check for updates without installing
  -f, --force       Force reinstall even if up to date
  -y, --yes         Skip confirmation prompt
  -h, --help        Show this help message
  
Arguments:
  VERSION           Specific version to install (e.g., v0.2.0)
                   If not specified, installs the latest version

Examples:
  # Update to latest version
  sidekick update
  
  # Check for updates without installing
  sidekick update --check
  
  # Update to specific version
  sidekick update v0.2.0
  
  # Force reinstall current version
  sidekick update --force

Notes:
  - Requires sudo access for system-wide installation
  - Downloads from official GitHub releases
  - Preserves your configuration and environment settings
  - Always updates from the official repository
EOF
}

# Get current version
get_current_version() {
    local version_file=""
    
    # Check common installation locations
    if [ -f "/usr/local/share/sidekick/VERSION" ]; then
        version_file="/usr/local/share/sidekick/VERSION"
    elif [ -f "$SCRIPT_DIR/VERSION" ]; then
        version_file="$SCRIPT_DIR/VERSION"
    elif [ -f "$SCRIPT_DIR/../VERSION" ]; then
        version_file="$SCRIPT_DIR/../VERSION"
    fi
    
    if [ -n "$version_file" ] && [ -f "$version_file" ]; then
        cat "$version_file"
    else
        echo "unknown"
    fi
}

# Get repository info - always returns the official repo
get_repo_info() {
    # Always use the official sidekick repository for updates
    echo "aiconsultancy/sidekick"
}

# Get latest version from GitHub
get_latest_version() {
    local repo="$1"
    local api_url="https://api.github.com/repos/$repo/releases/latest"
    
    local version=$(curl -s "$api_url" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    
    if [ -z "$version" ]; then
        print_error "Could not fetch latest version from GitHub"
        exit 1
    fi
    
    echo "$version"
}

# Compare versions
version_compare() {
    local version1="$1"
    local version2="$2"
    
    # Remove 'v' prefix if present
    version1="${version1#v}"
    version2="${version2#v}"
    
    # If versions are identical
    if [ "$version1" = "$version2" ]; then
        echo "0"
        return
    fi
    
    # Compare using sort -V if available
    if command -v sort &> /dev/null && echo | sort -V &> /dev/null 2>&1; then
        local sorted=$(printf "%s\n%s" "$version1" "$version2" | sort -V | tail -1)
        if [ "$sorted" = "$version1" ]; then
            echo "1"  # version1 is newer
        else
            echo "-1" # version2 is newer
        fi
    else
        # Fallback to string comparison
        if [[ "$version1" > "$version2" ]]; then
            echo "1"
        else
            echo "-1"
        fi
    fi
}

# Check for updates
check_for_updates() {
    local current_version="$1"
    local latest_version="$2"
    
    if [ "$current_version" = "unknown" ]; then
        print_warning "Current version unknown, update recommended"
        return 0
    fi
    
    local comparison=$(version_compare "$latest_version" "$current_version")
    
    if [ "$comparison" -gt 0 ]; then
        print_info "Update available: $current_version → $latest_version"
        return 0
    elif [ "$comparison" -eq 0 ]; then
        print_success "Already up to date (version $current_version)"
        return 1
    else
        print_warning "Current version ($current_version) is newer than latest release ($latest_version)"
        return 1
    fi
}

# Download and install update
install_update() {
    local version="$1"
    local repo="$2"
    
    # Create temp directory
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT
    
    print_info "Downloading sidekick $version..."
    
    # Download install script
    local install_url="https://github.com/$repo/releases/download/$version/install.sh"
    
    if ! curl -sSL -o "$temp_dir/install.sh" "$install_url" 2>/dev/null; then
        print_error "Failed to download installer from $install_url"
        exit 1
    fi
    
    # Make installer executable
    chmod +x "$temp_dir/install.sh"
    
    # Set environment variables for installer
    export REPO_OWNER=$(echo "$repo" | cut -d'/' -f1)
    export REPO_NAME=$(echo "$repo" | cut -d'/' -f2)
    export VERSION="$version"
    
    # Run installer
    print_info "Installing sidekick $version..."
    if ! "$temp_dir/install.sh"; then
        print_error "Installation failed"
        exit 1
    fi
    
    print_success "Successfully updated to version $version"
}

# Main function
main() {
    local check_only=false
    local force_update=false
    local skip_confirm=false
    local target_version=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -c|--check)
                check_only=true
                shift
                ;;
            -f|--force)
                force_update=true
                shift
                ;;
            -y|--yes)
                skip_confirm=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                target_version="$1"
                shift
                ;;
        esac
    done
    
    # Get repository info
    local repo=$(get_repo_info)
    print_info "Repository: $repo"
    
    # Get current version
    local current_version=$(get_current_version)
    if [ "$current_version" != "unknown" ]; then
        print_info "Current version: $current_version"
    else
        print_warning "Current version: unknown"
    fi
    
    # Determine target version
    if [ -z "$target_version" ]; then
        print_info "Checking for updates..."
        target_version=$(get_latest_version "$repo")
    fi
    
    # Check if update is needed
    local needs_update=false
    if [ "$force_update" = true ]; then
        print_info "Force update requested"
        needs_update=true
    elif check_for_updates "$current_version" "$target_version"; then
        needs_update=true
    fi
    
    # If only checking, exit here
    if [ "$check_only" = true ]; then
        if [ "$needs_update" = true ]; then
            exit 0
        else
            exit 1
        fi
    fi
    
    # Exit if no update needed
    if [ "$needs_update" = false ]; then
        exit 0
    fi
    
    # Confirm update
    if [ "$skip_confirm" = false ]; then
        echo
        read -p "Do you want to update sidekick to version $target_version? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Update cancelled"
            exit 0
        fi
    fi
    
    # Perform update
    install_update "$target_version" "$repo"
    
    # Show new version
    local new_version=$(get_current_version)
    if [ "$new_version" != "unknown" ]; then
        print_success "Sidekick is now at version $new_version"
    fi
}

# Run main function
main "$@"