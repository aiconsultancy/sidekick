#!/usr/bin/env bash
set -euo pipefail

# Load common libraries
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PLUGIN_NAME="$(basename "$0")"
PLUGIN_LIB_DIR="$SCRIPT_DIR/lib/$PLUGIN_NAME"

# Load plugin-specific libraries
if [[ -d "$PLUGIN_LIB_DIR" ]]; then
    for lib in "$PLUGIN_LIB_DIR"/*.sh; do
        [[ -f "$lib" ]] && source "$lib"
    done
fi

# Load global libraries
source "$SCRIPT_DIR/../lib/config.sh" 2>/dev/null || true
source "$SCRIPT_DIR/../lib/output_helpers.sh" 2>/dev/null || true

# Define helper functions if not already defined
if ! command -v info &> /dev/null; then
    info() {
        echo "ℹ $1"
    }
fi

if ! command -v success &> /dev/null; then
    success() {
        echo "✓ $1"
    }
fi

if ! command -v error &> /dev/null; then
    error() {
        echo "✗ $1" >&2
    }
fi

if ! command -v warning &> /dev/null; then
    warning() {
        echo "⚠ $1"
    }
fi

# Default configuration
DEFAULT_AI_AGENT="claude"
DEFAULT_CLAUDE_MODEL="claude-3-5-haiku-20241022"

# Parse arguments
PR_NUMBER=""
FORCE=false
DRY_RUN=false
CHECK_ALL=false
FIX_ALL=false
AI_AGENT="${SIDEKICK_PR_RENAME_AI_AGENT:-$DEFAULT_AI_AGENT}"
CLAUDE_MODEL="${SIDEKICK_PR_RENAME_CLAUDE_MODEL:-$DEFAULT_CLAUDE_MODEL}"

show_help() {
    cat << EOF
Usage: sidekick run pr-rename [OPTIONS] [PR_NUMBER]

Rename pull request titles to include module identifiers (M{module}.{submodule}.{task})

Arguments:
  PR_NUMBER              PR number to rename (optional, uses current branch's PR if not specified)

Options:
  -h, --help            Show this help message
  -f, --force           Force rename even if module ID already exists
  -d, --dry-run         Show what would be renamed without making changes
  -c, --check-all       Check all open PRs for missing/incorrect module IDs
  --fix-all             Automatically fix all PRs that need module IDs (implies --check-all)
  --ai-agent AGENT      AI agent to use for extraction (claude, opencode, etc.)
  --model MODEL         Model to use for Claude (default: $DEFAULT_CLAUDE_MODEL)

Environment Variables:
  SIDEKICK_PR_RENAME_AI_AGENT    Default AI agent (default: claude)
  SIDEKICK_PR_RENAME_CLAUDE_MODEL Claude model to use (default: claude-3-5-haiku-20241022)

Examples:
  sidekick run pr-rename                  # Rename current branch's PR
  sidekick run pr-rename 123               # Rename PR #123
  sidekick run pr-rename -d                # Dry run to see what would happen
  sidekick run pr-rename -c                # Check all open PRs for missing module IDs
  sidekick run pr-rename -c -d             # Check all PRs without making changes
  sidekick run pr-rename --fix-all         # Fix all PRs that need module IDs
  sidekick run pr-rename --fix-all -d      # Preview what would be fixed
  sidekick run pr-rename --ai-agent opencode  # Use opencode for extraction

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -c|--check-all)
            CHECK_ALL=true
            shift
            ;;
        --fix-all)
            FIX_ALL=true
            CHECK_ALL=true  # fix-all implies check-all
            shift
            ;;
        --ai-agent)
            AI_AGENT="$2"
            shift 2
            ;;
        --model)
            CLAUDE_MODEL="$2"
            shift 2
            ;;
        *)
            if [[ -z "$PR_NUMBER" ]]; then
                PR_NUMBER="$1"
            else
                error "Unknown argument: $1"
                show_help
                exit 1
            fi
            shift
            ;;
    esac
done

# Process all open PRs
process_all_prs() {
    info "Fetching all open PRs..."
    
    # Get all open PRs with their details
    local pr_list=$(gh pr list --state open --json number,title,headRefName --limit 100 2>/dev/null) || {
        error "Failed to fetch PR list"
        return 1
    }
    
    local pr_count=$(echo "$pr_list" | jq 'length')
    if [[ "$pr_count" -eq 0 ]]; then
        info "No open PRs found"
        return 0
    fi
    
    success "Found $pr_count open PRs"
    echo
    
    local checked=0
    local needs_update=0
    local updated=0
    local failed=0
    
    # Process each PR
    echo "$pr_list" | jq -c '.[]' | while IFS= read -r pr_data; do
        local pr_number=$(echo "$pr_data" | jq -r '.number')
        local pr_title=$(echo "$pr_data" | jq -r '.title')
        local pr_branch=$(echo "$pr_data" | jq -r '.headRefName')
        
        ((checked++))
        info "[$checked/$pr_count] Checking PR #$pr_number: $pr_title"
        
        # Check if this PR needs updating
        local module_id=""
        local existing_id=""
        local should_update=false
        
        # Extract module ID from branch name first
        if [[ "$pr_branch" =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            module_id="M${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
        else
            # Try to extract from PR body using AI if no branch pattern
            local pr_body=$(gh pr view "$pr_number" --json body --jq '.body // ""' 2>/dev/null || echo "")
            if [[ -n "$pr_body" ]]; then
                module_id=$(extract_module_from_description "$pr_body" "$AI_AGENT" "$CLAUDE_MODEL" 2>/dev/null || echo "")
            fi
        fi
        
        # Check if title already has a module ID
        if [[ "$pr_title" =~ (M[0-9]+\.[0-9]+\.[0-9]+) ]]; then
            existing_id="${BASH_REMATCH[1]}"
        fi
        
        # Determine if update is needed
        if [[ -n "$module_id" ]]; then
            if [[ -z "$existing_id" ]]; then
                should_update=true
                echo "  → Missing module ID, should add: $module_id"
            elif [[ "$existing_id" != "$module_id" ]]; then
                should_update=true
                echo "  → Wrong module ID ($existing_id), should be: $module_id"
            else
                echo "  ✓ Already has correct module ID: $existing_id"
            fi
        else
            echo "  ⚠ No module ID found in branch or description"
        fi
        
        if [[ "$should_update" == true ]]; then
            ((needs_update++))
            
            # If fix-all mode, actually update the PR
            if [[ "$FIX_ALL" == true ]] && [[ "$DRY_RUN" != true ]]; then
                local new_title=$(echo "$pr_title" | sed -E 's/[[:space:]]*\(?M[0-9]+\.[0-9]+\.[0-9]+\)?//g' | sed 's/[[:space:]]*$//')
                new_title="$new_title ($module_id)"
                
                if gh pr edit "$pr_number" --title "$new_title" 2>/dev/null; then
                    success "  ✓ Updated PR #$pr_number title"
                    ((updated++))
                else
                    error "  ✗ Failed to update PR #$pr_number"
                    ((failed++))
                fi
            elif [[ "$FIX_ALL" == true ]] && [[ "$DRY_RUN" == true ]]; then
                local new_title=$(echo "$pr_title" | sed -E 's/[[:space:]]*\(?M[0-9]+\.[0-9]+\.[0-9]+\)?//g' | sed 's/[[:space:]]*$//')
                new_title="$new_title ($module_id)"
                echo "  → Would update to: $new_title"
            fi
        fi
        
        echo
    done
    
    # Wait for the subshell to complete and capture the counts
    # Note: We need to use files to pass data back from the subshell
    local temp_dir=$(mktemp -d)
    local count_file="$temp_dir/counts"
    
    echo "$pr_list" | jq -c '.[]' | {
        local checked=0
        local needs_update=0
        local updated=0
        local failed=0
        
        while IFS= read -r pr_data; do
            local pr_number=$(echo "$pr_data" | jq -r '.number')
            local pr_title=$(echo "$pr_data" | jq -r '.title')
            local pr_branch=$(echo "$pr_data" | jq -r '.headRefName')
            
            ((checked++))
            
            # Check if this PR needs updating
            local module_id=""
            local existing_id=""
            local should_update=false
            
            # Extract module ID from branch name first
            if [[ "$pr_branch" =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
                module_id="M${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
            else
                # Try to extract from PR body using AI if no branch pattern
                local pr_body=$(gh pr view "$pr_number" --json body --jq '.body // ""' 2>/dev/null || echo "")
                if [[ -n "$pr_body" ]]; then
                    module_id=$(extract_module_from_description "$pr_body" "$AI_AGENT" "$CLAUDE_MODEL" 2>/dev/null || echo "")
                fi
            fi
            
            # Check if title already has a module ID
            if [[ "$pr_title" =~ (M[0-9]+\.[0-9]+\.[0-9]+) ]]; then
                existing_id="${BASH_REMATCH[1]}"
            fi
            
            # Determine if update is needed
            if [[ -n "$module_id" ]]; then
                if [[ -z "$existing_id" ]] || [[ "$existing_id" != "$module_id" ]]; then
                    should_update=true
                fi
            fi
            
            if [[ "$should_update" == true ]]; then
                ((needs_update++))
                
                # If fix-all mode, actually update the PR
                if [[ "$FIX_ALL" == true ]] && [[ "$DRY_RUN" != true ]]; then
                    local new_title=$(echo "$pr_title" | sed -E 's/[[:space:]]*\(?M[0-9]+\.[0-9]+\.[0-9]+\)?//g' | sed 's/[[:space:]]*$//')
                    new_title="$new_title ($module_id)"
                    
                    if gh pr edit "$pr_number" --title "$new_title" 2>/dev/null; then
                        ((updated++))
                    else
                        ((failed++))
                    fi
                fi
            fi
        done
        
        echo "$checked:$needs_update:$updated:$failed" > "$count_file"
    }
    
    # Read the results
    local counts=$(cat "$count_file")
    rm -rf "$temp_dir"
    
    local checked=$(echo "$counts" | cut -d: -f1)
    local needs_update=$(echo "$counts" | cut -d: -f2)
    local updated=$(echo "$counts" | cut -d: -f3)
    local failed=$(echo "$counts" | cut -d: -f4)
    
    # Summary
    echo "=========================================="
    success "Checked $checked PRs"
    
    if [[ "$needs_update" -gt 0 ]]; then
        warning "$needs_update PRs need module ID updates"
        
        if [[ "$FIX_ALL" == true ]]; then
            if [[ "$DRY_RUN" == true ]]; then
                info "Run without --dry-run to apply the changes"
            else
                success "$updated PRs updated successfully"
                if [[ "$failed" -gt 0 ]]; then
                    error "$failed PRs failed to update"
                fi
            fi
        else
            info "Use --fix-all to automatically update them"
        fi
    else
        success "All PRs have correct module IDs!"
    fi
    
    return 0
}

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    error "Not in a git repository"
    exit 1
fi

# Check for gh CLI
if ! command -v gh &> /dev/null; then
    error "GitHub CLI (gh) is required but not installed"
    info "Install with: brew install gh"
    exit 1
fi

# Handle check-all and fix-all modes
if [[ "$CHECK_ALL" == true ]]; then
    process_all_prs
    exit $?
fi

# Get current branch name if PR number not specified
if [[ -z "$PR_NUMBER" ]]; then
    CURRENT_BRANCH=$(git branch --show-current)
    if [[ "$CURRENT_BRANCH" == "main" ]] || [[ "$CURRENT_BRANCH" == "master" ]]; then
        error "Cannot determine PR from main/master branch. Please specify PR number."
        exit 1
    fi
    
    # Try to get PR number for current branch
    PR_NUMBER=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number' 2>/dev/null || echo "")
    
    if [[ -z "$PR_NUMBER" ]]; then
        error "No PR found for current branch '$CURRENT_BRANCH'"
        info "Create a PR first with: gh pr create"
        exit 1
    fi
    
    info "Using PR #$PR_NUMBER for branch '$CURRENT_BRANCH'"
fi

# Get PR details
info "Fetching PR #$PR_NUMBER details..."
PR_DATA=$(gh pr view "$PR_NUMBER" --json title,body,headRefName 2>/dev/null) || {
    error "Failed to fetch PR #$PR_NUMBER"
    exit 1
}

PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
PR_BODY=$(echo "$PR_DATA" | jq -r '.body // ""')
PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headRefName')

success "Found PR: $PR_TITLE"
info "Branch: $PR_BRANCH"

# Try to extract module ID from branch name first
MODULE_ID=""
if [[ "$PR_BRANCH" =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
    MODULE_ID="M${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
    success "Extracted module ID from branch: $MODULE_ID"
else
    info "No module ID found in branch name, checking PR description..."
    
    # Try to extract from PR body using AI
    if [[ -n "$PR_BODY" ]]; then
        MODULE_ID=$(extract_module_from_description "$PR_BODY" "$AI_AGENT" "$CLAUDE_MODEL")
        if [[ -n "$MODULE_ID" ]]; then
            success "Extracted module ID from description: $MODULE_ID"
        fi
    fi
fi

if [[ -z "$MODULE_ID" ]]; then
    error "Could not extract module ID from branch name or PR description"
    info "Expected format in branch: X.Y.Z (e.g., feat/2.2.13-feature-name)"
    info "Or in description: 'module 2.2 ... Task 13' or similar"
    exit 1
fi

# Check if title already has the same module ID anywhere in it
if [[ "$PR_TITLE" =~ (M[0-9]+\.[0-9]+\.[0-9]+) ]]; then
    EXISTING_ID="${BASH_REMATCH[1]}"
    if [[ "$EXISTING_ID" == "$MODULE_ID" ]]; then
        success "PR title already contains the correct module ID: $EXISTING_ID"
        exit 0
    elif [[ "$FORCE" != true ]]; then
        warning "PR title contains a different module ID: $EXISTING_ID"
        info "Extracted module ID: $MODULE_ID"
        info "Use -f/--force to replace with the correct ID"
        exit 0
    else
        info "Replacing existing module ID $EXISTING_ID with $MODULE_ID"
    fi
fi

# Remove any existing module ID from the title (could be anywhere)
NEW_TITLE=$(echo "$PR_TITLE" | sed -E 's/[[:space:]]*\(?M[0-9]+\.[0-9]+\.[0-9]+\)?//g' | sed 's/[[:space:]]*$//')

# Add new module ID at the end in parentheses
NEW_TITLE="$NEW_TITLE ($MODULE_ID)"

# Show what will be done
echo
info "Current title: $PR_TITLE"
success "New title:     $NEW_TITLE"

# Execute or dry run
if [[ "$DRY_RUN" == true ]]; then
    echo
    warning "DRY RUN - No changes made"
else
    echo
    info "Updating PR title..."
    gh pr edit "$PR_NUMBER" --title "$NEW_TITLE" || {
        error "Failed to update PR title"
        exit 1
    }
    success "PR #$PR_NUMBER title updated successfully!"
fi