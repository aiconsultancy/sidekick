#!/bin/bash

# Sidekick - Extensible command-line tool for development workflows
# Similar to kubectl, this acts as a dispatcher for sidekick-* subcommands

set -e

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Version
VERSION="1.0.0"

# Function to print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}$@${NC}"
}

# Function to find available commands
find_commands() {
    # Include plugins folder in search paths
    local search_paths=("$SCRIPT_DIR" "$SCRIPT_DIR/plugins" "$HOME/.local/bin" "/usr/local/bin")
    local commands=()
    
    for path in "${search_paths[@]}"; do
        if [[ -d "$path" ]]; then
            # Find all executable files matching sidekick-*
            while IFS= read -r cmd; do
                if [[ -x "$cmd" ]]; then
                    basename "$cmd"
                fi
            done < <(find "$path" -maxdepth 1 -name "sidekick-*" 2>/dev/null)
        fi
    done | sort -u
}

# Function to parse command name into verb and noun
parse_command() {
    local cmd_name=$1
    # Remove sidekick- prefix
    local cmd_parts=${cmd_name#sidekick-}
    # Remove any extension
    cmd_parts=${cmd_parts%.*}
    echo "$cmd_parts"
}

# Function to show available commands
show_commands() {
    print_color "$BOLD" "Available Commands:"
    echo ""
    
    local current_verb=""
    while IFS= read -r cmd; do
        local parsed=$(parse_command "$cmd")
        # Try to split into verb-noun, but handle single word commands too
        local verb=$(echo "$parsed" | cut -d'-' -f1)
        local noun=$(echo "$parsed" | cut -d'-' -f2-)
        
        if [[ "$verb" != "$current_verb" ]]; then
            if [[ -n "$current_verb" ]]; then
                echo ""
            fi
            print_color "$CYAN" "  $verb"
            current_verb="$verb"
        fi
        
        if [[ "$noun" != "$verb" ]]; then
            echo "    $noun"
        else
            # Single word command (no noun)
            echo "    (default)"
        fi
    done < <(find_commands)
    
    echo ""
    print_color "$BOLD" "Usage:"
    echo "  sidekick <verb> <noun> [options] [arguments]"
    echo "  sidekick <command> [options] [arguments]"
    echo ""
    print_color "$BOLD" "Examples:"
    echo "  sidekick get pr-comments https://github.com/org/repo/pull/123"
    echo "  sidekick get pr-comments --help"
    echo ""
    print_color "$BOLD" "Global Options:"
    echo "  -h, --help     Show this help message"
    echo "  -v, --version  Show version information"
    echo "  --list         List all available commands"
}

# Function to find and execute command
execute_command() {
    local verb=$1
    local noun=$2
    shift 2 || true
    
    # Search paths - include plugins folder
    local search_paths=("$SCRIPT_DIR" "$SCRIPT_DIR/plugins" "$HOME/.local/bin" "/usr/local/bin")
    
    # First, try verb-noun combination if noun is provided and not a flag
    if [[ -n "$noun" ]] && [[ ! "$noun" =~ ^- ]]; then
        local possibilities=(
            "sidekick-${verb}-${noun}"
            "sidekick-${verb}-${noun}.sh"
            "sidekick-${verb}-${noun}.py"
            "sidekick-${verb}-${noun}.js"
        )
        
        for cmd_pattern in "${possibilities[@]}"; do
            for path in "${search_paths[@]}"; do
                local full_path="$path/$cmd_pattern"
                if [[ -x "$full_path" ]]; then
                    # Found verb-noun command
                    exec "$full_path" "$@"
                fi
            done
        done
    fi
    
    # If verb-noun not found, try just the verb as a single command
    # Put the noun back as an argument if it's not a flag
    if [[ -n "$noun" ]] && [[ ! "$noun" =~ ^- ]]; then
        set -- "$noun" "$@"
    fi
    
    local possibilities=(
        "sidekick-${verb}"
        "sidekick-${verb}.sh"
        "sidekick-${verb}.py"
        "sidekick-${verb}.js"
    )
    
    for cmd_pattern in "${possibilities[@]}"; do
        for path in "${search_paths[@]}"; do
            local full_path="$path/$cmd_pattern"
            if [[ -x "$full_path" ]]; then
                # Found single-word command
                exec "$full_path" "$@"
            fi
        done
    done
    
    # Command not found
    print_color "$RED" "Error: Unknown command '${verb}${noun:+ $noun}'"
    echo ""
    echo "Run 'sidekick --help' for usage."
    exit 1
}

# Main logic
main() {
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_commands
        exit 0
    fi
    
    # Handle global flags
    case "$1" in
        -h|--help|help)
            show_commands
            exit 0
            ;;
        -v|--version|version)
            echo "sidekick version $VERSION"
            exit 0
            ;;
        --list|list)
            print_color "$BOLD" "Available sidekick commands:"
            find_commands | while read -r cmd; do
                echo "  $(parse_command "$cmd")"
            done
            exit 0
            ;;
        -*)
            print_color "$RED" "Error: Unknown flag '$1'"
            echo "Run 'sidekick --help' for usage."
            exit 1
            ;;
    esac
    
    # Parse verb and potential noun
    local verb=$1
    shift
    
    # Check if next argument is a noun (not a flag)
    local noun=""
    if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
        noun=$1
        shift
    fi
    
    # Execute the command
    execute_command "$verb" "$noun" "$@"
}

# Run main function
main "$@"